#include <stdio.h>
#include <stdlib.h>

/**************
最小生成树指的是在一个带权值的无向连通图中，一个权值之和最小的极小连通图。
极小连通图的意思就是一个包含所有顶点，然后边数尽可能少的连通子图

构造最小连通子图的算法主要有两种：

1. prim算法
2. kruskal算法

以下通过伪代码的方式进行解释

*************/

// prim 算法以顶点扩展的方法进行，算法过程如下：
// 1.声明两个集合 A：存放未加入生成树集合的结点  B：存放加入生成树集合的结点。
// 2. 将第一个结点加入B，从A中将之删除。
// 3. 然后找到一个权值最小的边，使其满足两个端点一个来自A，一个来自B,然后将来自A的结点加入B，然后从A中删除之。
// 4. 重复步骤3，直到所有结点都加入了B，算法结束

// 算法的时间复杂度为O(V^2),V为顶点数，不依赖边，适合求解稠密型的图的最小生成树

void Prim(G, T){
    V = G->vertex;  // 得到图的所有顶点
    T = nullSet;    //  初始化空树
    U = {w};        // 添加任一顶点w，作为树的起始结点
    while(( V - U ) != nullSet){ // 空集
        设(u, v)是使u∈U和v∈(V-U)，且权值最小的边
         T = T + {(u, v)} // 将边加入最小生成树
         U = U + u;       // 将顶点加入最小生成树的顶点击
    }
}

// Kruskal 算法是以扩展边的方法进行，算法过程如下：
// 1. 选择权值最小的一条边，和其两个端点，加入生成树的边集和点集。
// 2. 按权值递增的顺序选择边，如果加入的边不构成回路，则加入，否则舍弃。
// 3. 直到生成树中有 n-1个边，算法结束.

// 算法时间复杂度为O(ElogE)，E为边数，不依赖顶点数，适合求解稀疏且顶点多的图.
// 我们使用堆来存放边，故每次查找最小边的时间复杂度为O(logE)，此外还需要判断边两个顶点是否分别属于两个集合，时间复杂度为O(E)。

void Kruskal(V, T){
    T = V;           // 初始化空树，仅含顶点
    sumS = n;        // 连通分量数
    while(numS > 1){
        从E中找出权值最小的边(u, v);
        if(v 和 u属于不同的连通分量){
            T = T + {(u, v)};  //将边加入最小生成树
            numS --;           // 连通分量减1
        }
    }
}

int main()
{
    printf("Hello world!\n");
    return 0;
}
